"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2669],{2032:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>c});var a=n(1318);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var p=a.createContext({}),u=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},s=function(e){var t=u(e.components);return a.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,r=e.originalType,p=e.parentName,s=i(e,["components","mdxType","originalType","parentName"]),d=u(n),c=l,k=d["".concat(p,".").concat(c)]||d[c]||m[c]||r;return n?a.createElement(k,o(o({ref:t},s),{},{components:n})):a.createElement(k,o({ref:t},s))}));function c(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=n.length,o=new Array(r);o[0]=d;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i.mdxType="string"==typeof e?e:l,o[1]=i;for(var u=2;u<r;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8917:(e,t,n)=>{n.d(t,{Z:()=>o});var a=n(1318),l=n(6184);const r="tabItem_lJP0";function o(e){let{children:t,hidden:n,className:o}=e;return a.createElement("div",{role:"tabpanel",className:(0,l.Z)(r,o),hidden:n},t)}},7516:(e,t,n)=>{n.d(t,{Z:()=>c});var a=n(4219),l=n(1318),r=n(6184),o=n(4045),i=n(3872),p=n(950),u=n(3773);const s="tabList_mO4X",m="tabItem_Gzb_";function d(e){var t,n;const{lazy:o,block:d,defaultValue:c,values:k,groupId:h,className:v}=e,g=l.Children.map(e.children,(e=>{if((0,l.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),N=null!=k?k:g.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),b=(0,i.l)(N,((e,t)=>e.value===t.value));if(b.length>0)throw new Error('Docusaurus error: Duplicate values "'+b.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.');const y=null===c?c:null!=(t=null!=c?c:null==(n=g.find((e=>e.props.default)))?void 0:n.props.value)?t:g[0].props.value;if(null!==y&&!N.some((e=>e.value===y)))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+y+'" but none of its children has the corresponding value. Available values are: '+N.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");const{tabGroupChoices:x,setTabGroupChoices:f}=(0,p.U)(),[C,B]=(0,l.useState)(y),T=[],{blockElementScrollPositionUntilNextRender:w}=(0,u.o5)();if(null!=h){const e=x[h];null!=e&&e!==C&&N.some((t=>t.value===e))&&B(e)}const j=e=>{const t=e.currentTarget,n=T.indexOf(t),a=N[n].value;a!==C&&(w(t),B(a),null!=h&&f(h,String(a)))},H=e=>{var t;let n=null;switch(e.key){case"Enter":j(e);break;case"ArrowRight":{var a;const t=T.indexOf(e.currentTarget)+1;n=null!=(a=T[t])?a:T[0];break}case"ArrowLeft":{var l;const t=T.indexOf(e.currentTarget)-1;n=null!=(l=T[t])?l:T[T.length-1];break}}null==(t=n)||t.focus()};return l.createElement("div",{className:(0,r.Z)("tabs-container",s)},l.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":d},v)},N.map((e=>{let{value:t,label:n,attributes:o}=e;return l.createElement("li",(0,a.Z)({role:"tab",tabIndex:C===t?0:-1,"aria-selected":C===t,key:t,ref:e=>T.push(e),onKeyDown:H,onClick:j},o,{className:(0,r.Z)("tabs__item",m,null==o?void 0:o.className,{"tabs__item--active":C===t})}),null!=n?n:t)}))),o?(0,l.cloneElement)(g.filter((e=>e.props.value===C))[0],{className:"margin-top--md"}):l.createElement("div",{className:"margin-top--md"},g.map(((e,t)=>(0,l.cloneElement)(e,{key:t,hidden:e.props.value!==C})))))}function c(e){const t=(0,o.Z)();return l.createElement(d,(0,a.Z)({key:String(t)},e))}},4633:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>p,default:()=>c,frontMatter:()=>i,metadata:()=>u,toc:()=>m});var a=n(4219),l=(n(1318),n(2032)),r=n(7516),o=n(8917);const i={title:"Expect"},p=void 0,u={unversionedId:"api/expect",id:"api/expect",title:"Expect",description:"toBe",source:"@site/docs/api/expect.mdx",sourceDirName:"api",slug:"/api/expect",permalink:"/xbell/zh-CN/docs/api/expect",draft:!1,editUrl:"https://github.com/x-bell/xbell/tree/main/website/docs/api/expect.mdx",tags:[],version:"current",frontMatter:{title:"Expect"},sidebar:"api",previous:{title:"Config",permalink:"/xbell/zh-CN/docs/api/config"},next:{title:"CLI",permalink:"/xbell/zh-CN/docs/api/cli"}},s={},m=[{value:'toBe<tag type="node.js" /><tag type="browser" />',id:"tobe",level:3},{value:"toEqual",id:"toequal",level:3},{value:"toContain",id:"tocontain",level:3},{value:"toContainEqual",id:"tocontainequal",level:3},{value:'toBeDefined<tag type="node.js" /><tag type="browser" />',id:"tobedefined",level:3},{value:'toBeUndefined <tag type="node.js" /><tag type="browser" />',id:"tobeundefined-",level:3},{value:'toBeNull <tag type="node.js" /><tag type="browser" />',id:"tobenull-",level:3},{value:"toBeTruthy",id:"tobetruthy",level:3},{value:"toBeFalsy",id:"tobefalsy",level:3},{value:"toHaveLength",id:"tohavelength",level:3},{value:"toBeTypeOf",id:"tobetypeof",level:3},{value:"toBeLessThan",id:"tobelessthan",level:3},{value:"toBeLessThanOrEqual",id:"tobelessthanorequal",level:3},{value:"toBeGreaterThan",id:"tobegreaterthan",level:3},{value:"toBeGreaterThanOrEqual",id:"tobegreaterthanorequal",level:3},{value:"toBeNaN",id:"tobenan",level:3},{value:"toBeCloseTo",id:"tobecloseto",level:3},{value:"toHaveProperty",id:"tohaveproperty",level:3},{value:"toHaveBeenCalled",id:"tohavebeencalled",level:3},{value:"toHaveBeenCalledTimes",id:"tohavebeencalledtimes",level:3},{value:"toHaveBeenCalledWith",id:"tohavebeencalledwith",level:3},{value:"toHaveBeenLastCalledWith",id:"tohavebeenlastcalledwith",level:3},{value:"toHaveBeenNthCalledWith",id:"tohavebeennthcalledwith",level:3},{value:"toHaveReturned",id:"tohavereturned",level:3},{value:"toHaveReturnedTimes",id:"tohavereturnedtimes",level:3},{value:"toHaveReturnedWith",id:"tohavereturnedwith",level:3},{value:"toHaveLastReturnedWith",id:"tohavelastreturnedwith",level:3},{value:"toHaveNthReturnedWith",id:"tohaventhreturnedwith",level:3},{value:'toBeVisible <tag type="node.js" />',id:"tobevisible-",level:3},{value:"toBeHidden",id:"tobehidden",level:3},{value:"toBeChecked",id:"tobechecked",level:3},{value:"toBeDisabled",id:"tobedisabled",level:3},{value:"toBeEmpty",id:"tobeempty",level:3},{value:"toBeEnabled",id:"tobeenabled",level:3},{value:"toBeFocused",id:"tobefocused",level:3},{value:"toHaveText",id:"tohavetext",level:3},{value:"toContainText",id:"tocontaintext",level:3},{value:"toHaveAttribute",id:"tohaveattribute",level:3},{value:"toHaveClass",id:"tohaveclass",level:3},{value:"toHaveId",id:"tohaveid",level:3},{value:"toHaveCount",id:"tohavecount",level:3},{value:"toMatchImageScreenshot",id:"tomatchimagescreenshot",level:3},{value:"toMatchSnapshot",id:"tomatchsnapshot",level:3}],d={toc:m};function c(e){let{components:t,...n}=e;return(0,l.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h3",{id:"tobe"},"toBe",(0,l.kt)("tag",{type:"node.js"}),(0,l.kt)("tag",{type:"browser"})),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toBe(expected)")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received")," ",(0,l.kt)("type",null,"any")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"expected")," ",(0,l.kt)("type",null,"any"))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)("p",null,'"toBe" is used to compare whether the primitive values are equal or whether objects belong to the same reference.'),(0,l.kt)(r.Z,{mdxType:"Tabs"},(0,l.kt)(o.Z,{value:"node.js",label:"node.js",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"import { test, expect } from 'xbell';\n\nconst man = {\n  name: 'Mike',\n  bag: ['vodka'],\n};\n\ntest('check primitives value', () => {\n  expect(man.name).toBe('Mike');\n});\n\ntest('check reference value', () => {\n  const bagRef = man.bag;\n\n  expect(man.bag).toBe(bagRef);\n  expect(man.bag).not.toBe(['vodka']);\n});\n\n"))),(0,l.kt)(o.Z,{value:"browser",label:"browser",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript",metastring:'title="man.js"',title:'"man.js"'},"export const man = {\n  name: 'Mike',\n  bag: ['vodka'],\n};\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript",metastring:'title="man.test.js"',title:'"man.test.js"'},"import { test } from 'xbell';\n\ntest.browser('check primitives value', ({ expect }) => {\n  const { man } = await import('./man');\n\n  expect(man.name).toBe('Mike');\n});\n\ntest.browser('check reference value', ({ expect }) => {\n  const { man } = await import('./man');\n\n  const bagRef = man.bag;\n\n  expect(man.bag).toBe(bagRef);\n  expect(man.bag).not.toBe(['vodka']);\n});\n"))),(0,l.kt)(o.Z,{value:"mixed",label:"mixed",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript",metastring:'title="man.js"',title:'"man.js"'},"export const man = {\n  name: 'Mike',\n  bag: ['vodka'],\n};\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript",metastring:'title="man.test.js"',title:'"man.test.js"'},"import { test, expect } from 'xbell';\n\ntest('check primitives value', async ({ page }) => {\n  const nameHandle = await page.evaluate(async () => {\n    const { man } = await import('./man');\n    return man.name;\n  });\n  expect(nameHandle.toValue()).toBe('Mike');\n});\n\ntest('check reference value', async ({ page }) => {\n  const bagHanlde = await page.evaluate(async () => {\n    const { man } = await import('./man');\n    return man.bag;\n  });\n  \n  expect(bagHanlde.toValue()).not.toBe(['vodka']);\n  // NOTE: should use equal\n  expect(bagHanlde.toValue()).toEqual(['vodka']);\n});\n")))),(0,l.kt)("h3",{id:"toequal"},"toEqual"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toEqual(value)")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received")," ",(0,l.kt)("type",null,"any")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"value")," ",(0,l.kt)("type",null,"any"))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"toEqual"),' is used to assert that compare recursively all properties of object instances (also known as "deep" equality). '),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"import { test } from 'xbell';\n\ntest('toEqual', ({ expect }) => {\n  const obj1 = {\n    key: 'value',\n  };\n\n  const obj2 = {\n    key: 'value',\n  };\n\n  expect(obj1).not.toBe(obj2);\n  // to euqal\n  expect(obj1).toEqual(obj2);\n});\n")),(0,l.kt)("h3",{id:"tocontain"},"toContain"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toContain(value)")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received"),(0,l.kt)("type",null,"Array | string | IterableIterator")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"value")," ",(0,l.kt)("type",null,"any"))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"toContain")," is used to assert that an item is in an array. It uses ",(0,l.kt)("inlineCode",{parentName:"p"},"==="),", a strict equality check."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"import { test } from 'xbell';\n\ntest('toContain', ({ expect }) => {\n  expect([1, 2, 3]).toContain(1);\n  expect('abc').toContain('a');\n});\n")),(0,l.kt)("h3",{id:"tocontainequal"},"toContainEqual"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toContainEqual(value)")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received"),(0,l.kt)("type",null,"Array | string | IterableIterator")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"value")," ",(0,l.kt)("type",null,"any"))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"toContainEqual")," is used to assert that an item is in an array. It uses ",(0,l.kt)("inlineCode",{parentName:"p"},"toEqual")," to compare item."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"import { test } from 'xbell';\n\ntest('toContainEqual', ({ expect }) => {\n  expect([{ key: 'value' }]).toContainEqual({ key: 'value' });\n  expect('abc').toContainEqual('a');\n});\n")),(0,l.kt)("h3",{id:"tobedefined"},"toBeDefined",(0,l.kt)("tag",{type:"node.js"}),(0,l.kt)("tag",{type:"browser"})),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toBeDefined()")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received")," ",(0,l.kt)("type",null,"any"))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"toBeDefined()")," is used to assert that the value is not equal to ",(0,l.kt)("inlineCode",{parentName:"p"},"undefined")," , same as ",(0,l.kt)("inlineCode",{parentName:"p"},".not.toBe(undefined)")," ."),(0,l.kt)("p",null,"Usually used to check if a function has a return value."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"import { test, expect } from 'xbell';\n\nfunction createSomething() {\n  return Math.random();\n}\n\ntest('it always creates something', () => {\n  expect(createSomething()).toBeDefined();\n});\n")),(0,l.kt)("h3",{id:"tobeundefined-"},"toBeUndefined ",(0,l.kt)("tag",{type:"node.js"}),(0,l.kt)("tag",{type:"browser"})),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toBeUndefined()")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received")," ",(0,l.kt)("type",null,"any"))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"toBeUndefined()")," is used to assert that the value is ",(0,l.kt)("inlineCode",{parentName:"p"},"undefined")," , same as ",(0,l.kt)("inlineCode",{parentName:"p"},"toBe(undefined)")," ."),(0,l.kt)("p",null,"Usually used to check if a function returns undefined."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Exmaple")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"import { test, expect } from 'xbell';\n\nfunction getName(person) {\n  return person?.name;\n}\n\ntest('getName returns undefined when passed a empty value', () => {\n  expect(getName()).toBeUndefined();\n});\n")),(0,l.kt)("h3",{id:"tobenull-"},"toBeNull ",(0,l.kt)("tag",{type:"node.js"}),(0,l.kt)("tag",{type:"browser"})),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toBeNull()")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received")," ",(0,l.kt)("type",null,"any"))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"toBeNull()")," asserts that the value is ",(0,l.kt)("inlineCode",{parentName:"p"},"null")," , same as ",(0,l.kt)("inlineCode",{parentName:"p"},"toBe(null)")," ."),(0,l.kt)(r.Z,{mdxType:"Tabs"},(0,l.kt)(o.Z,{value:"node.js",label:"node.js",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"import { test, expect } from 'xbell';\n\nfunction getSomething(make) {\n  if (make) {\n    return Math.random();\n  }\n\n  return null;\n}\n\ntest('get something is null', () => {\n  expect(getSomething()).toBeNull();\n});\n"))),(0,l.kt)(o.Z,{value:"browser",label:"browser",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript",metastring:'title="something.js"',title:'"something.js"'},"export function getSomething(make) {\n  if (make) {\n    return Math.random();\n  }\n\n  return null;\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript",metastring:'title="something.test.js"',title:'"something.test.js"'},"import { test } from 'xbell';\n\ntest.browser('get something is null', ({ expect }) => {\n  const { getSomething } = await import('./something');\n\n  expect(getSomething()).toBeNull();\n});\n")))),(0,l.kt)("h3",{id:"tobetruthy"},"toBeTruthy"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toBeTruthy()")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received")," ",(0,l.kt)("type",null,"any"))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)(r.Z,{mdxType:"Tabs"},(0,l.kt)(o.Z,{value:"node.js",label:"node.js",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"import { test, expect } from 'xbell';\n\nfunction createSomething() {\n  return 1 + Math.random();\n}\n\ntest('createSomething returns value to be truthy', () => {\n  expect(createSomething()).toBeTruthy();\n});\n"))),(0,l.kt)(o.Z,{value:"browser",label:"browser",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript",metastring:'title="something.js"',title:'"something.js"'},"export function createSomething() {\n  return 1 + Math.random();\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript",metastring:'title="something.test.js"',title:'"something.test.js"'},"import { test } from 'xbell';\n\ntest.browser('createSomething returns value to be truthy', ({ expect }) => {\n  const { createSomething } = await import('./something');\n\n  expect(createSomething()).toBeTruthy();\n});\n")))),(0,l.kt)("h3",{id:"tobefalsy"},"toBeFalsy"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toBeFalsy()")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received")," ",(0,l.kt)("type",null,"any"))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)(r.Z,{mdxType:"Tabs"},(0,l.kt)(o.Z,{value:"node.js",label:"node.js",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"import { test, expect } from 'xbell';\n\nfunction createNothing() {\n  return null;\n}\n\ntest('createSomething returns value to be falsy', () => {\n  expect(createNothing()).toBeFalsy();\n});\n"))),(0,l.kt)(o.Z,{value:"browser",label:"browser",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript",metastring:'title="something.js"',title:'"something.js"'},"export function createNothing() {\n  return null;\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript",metastring:'title="something.test.js"',title:'"something.test.js"'},"import { test } from 'xbell';\n\ntest.browser('createSomething returns value to be truthy', ({ expect }) => {\n  const { createNothing } = await import('./something');\n\n  expect(createNothing()).toBeFalsy();\n});\n")))),(0,l.kt)("h3",{id:"tohavelength"},"toHaveLength"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toHaveLength(length)")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received")," ",(0,l.kt)("type",null,"{ length: number }")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"length")," ",(0,l.kt)("type",null,"number"))),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"toHaveLength")," is used to check that an object has a ",(0,l.kt)("inlineCode",{parentName:"p"},".length")," property and it is set to a certain numeric value."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"test('toHaveLength', ({ expect }) => {\n  expect([1, 2, 3]).toHaveLength(3);\n  expect('a').toHaveLength(1);\n  expect('').not.toHaveLength(1);\n});\n")),(0,l.kt)("h3",{id:"tobetypeof"},"toBeTypeOf"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toBeTypeOf(type)")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received")," ",(0,l.kt)("type",null,"any")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"type")," ",(0,l.kt)("type",null,"{'function' | 'number' | 'string' | 'object' | 'boolean' | 'undefined' | 'symbol' | 'bigint'}"))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)(r.Z,{mdxType:"Tabs"},(0,l.kt)(o.Z,{value:"nodejs",label:"nodejs",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"  import { test } from 'xbell';\n\n  class Dog {\n    eat() {}\n  }\n\n  test('the dog has a method of eating', ({ expect }) => {\n    const dog = new Dog();\n\n    expect(dog.eat).toBeTypeOf('function');\n  });\n"))),(0,l.kt)(o.Z,{value:"browser",label:"browser",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript",metastring:'title="uploader.js"',title:'"uploader.js"'},"export class Uploader {\n  upload(file) {\n    return Promise.resolve(URL.createObjectURL(file));\n  }\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript",metastring:'title="uploader.test.js"',title:'"uploader.test.js"'},"import { test } from 'xbell';\n\ntest.browser('upload property is a function', ({ expect }) => {\n  const { Uploader } = await import('./uploader');\n  const uploader = new Uploader();\n\n  expect(uploader.upload).toBeTypeOf('function');\n});\n")))),(0,l.kt)("h3",{id:"tobelessthan"},"toBeLessThan"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toBeLessThan(num)")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received")," ",(0,l.kt)("type",null,"number")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"num")," ",(0,l.kt)("type",null,"number"))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)("h3",{id:"tobelessthanorequal"},"toBeLessThanOrEqual"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toBeLessThanOrEqual(num)")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received")," ",(0,l.kt)("type",null,"number")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"num")," ",(0,l.kt)("type",null,"number"))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"toBeLessThanOrEqual")," is used to assert that the value is less than or equal to the target value."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"import { test } from 'xbell';\n\ntest('toBeLessThanOrEqual', ({ expect }) => {\n  expect(6).toBeLessThanOrEqual(6);\n  expect(6).toBeLessThanOrEqual(8);\n});\n")),(0,l.kt)("h3",{id:"tobegreaterthan"},"toBeGreaterThan"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toBeGreaterThan(num)")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received")," ",(0,l.kt)("type",null,"number")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"num")," ",(0,l.kt)("type",null,"number"))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"toBeGreaterThan")," is used to assert that the value is greater than the target value."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"import { test } from 'xbell';\n\ntest('toBeLessThanOrEqual', ({ expect }) => {\n  expect(6).toBeGreaterThan(5);\n});\n")),(0,l.kt)("h3",{id:"tobegreaterthanorequal"},"toBeGreaterThanOrEqual"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toBeGreaterThanOrEqual(num)")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received")," ",(0,l.kt)("type",null,"number")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"num")," ",(0,l.kt)("type",null,"number"))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"toBeGreaterThanOrEqual")," is used to assert that the value is greater than or equal to the target value."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"import { test } from 'xbell';\n\ntest('toBeGreaterThanOrEqual', ({ expect }) => {\n  expect(6).toBeGreaterThanOrEqual(5);\n  expect(6).toBeGreaterThanOrEqual(6);\n});\n")),(0,l.kt)("h3",{id:"tobenan"},"toBeNaN"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toBeNaN()")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received")," ",(0,l.kt)("type",null,"number"))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"toBeNaN")," is used to assert that the value is ",(0,l.kt)("inlineCode",{parentName:"p"},"NaN"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"test('toBeNaN', ({ expect }) => {\n  expect(NaN).toBeNaN();\n  expect(1).not.toBeNaN();\n});\n")),(0,l.kt)("h3",{id:"tobecloseto"},"toBeCloseTo"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toBeCloseTo(num, numDigits?)")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received")," ",(0,l.kt)("type",null,"number")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"num")," ",(0,l.kt)("type",null,"number")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"numDigits")," ",(0,l.kt)("type",null,"number"))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)("p",null,"Use ",(0,l.kt)("inlineCode",{parentName:"p"},"toBeCloseTo")," to compare floating point numbers for approximate equality."),(0,l.kt)("p",null,"The optional numDigits argument limits the number of digits to check after the decimal point. For the default value ",(0,l.kt)("inlineCode",{parentName:"p"},"2"),", the test criterion is ",(0,l.kt)("inlineCode",{parentName:"p"},"Math.abs(expected - received) < 0.005")," (that is, ",(0,l.kt)("inlineCode",{parentName:"p"},"10 ** -2 / 2"),")."),(0,l.kt)("p",null,"Intuitive equality comparisons often fail, because arithmetic on decimal (base 10) values often have rounding errors in limited precision binary (base 2) representation. For example, this test fails:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"test('adding works sanely with decimals', ({ expect }) => {\n  expect(0.2 + 0.1).toBe(0.3); // Fails!\n});\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"test('adding works sanely with decimals', ({ expect }) => {\n  expect(0.2 + 0.1).toBeCloseTo(0.3);\n});\n")),(0,l.kt)("h3",{id:"tohaveproperty"},"toHaveProperty"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toHaveProperty(key, value?)")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received")," ",(0,l.kt)("type",null,"number")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"key")," ",(0,l.kt)("type",null,"string")," object's key"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"value?")," ",(0,l.kt)("type",null,"any"))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)("h3",{id:"tohavebeencalled"},"toHaveBeenCalled"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toHaveBeenCalled()")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received")," ",(0,l.kt)("type",null,"Mock")," The mock function")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)("p",null,"Use ",(0,l.kt)("inlineCode",{parentName:"p"},"toHaveBeenCalled")," to ensure that a mock function is called."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Exmaple")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"import { test } from 'xbell';\n\ntest('toHaveBeenCalled', ({ expect, fn, spyOn }) => {\n  const object = {\n    method() {}\n  };\n\n  const handleClick = fn();\n  spyOn(object, 'method');\n\n  handleClick();\n  object.method();\n\n  expect(handleClick).toHaveBeenCalled();\n  expect(object.method).toHaveBeenCalled();\n});\n")),(0,l.kt)("h3",{id:"tohavebeencalledtimes"},"toHaveBeenCalledTimes"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toHaveBeenCalledTimes(times)")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received")," ",(0,l.kt)("type",null,"Mock")," The mock function"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"times")," ",(0,l.kt)("type",null,"number"))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)("p",null,"Use ",(0,l.kt)("inlineCode",{parentName:"p"},"toHaveBeenCalledTimes")," to ensure that a mock function got called exact number of times."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"import { test } from 'xbell';\n\ntest('toHaveBeenCalledTimes', ({ expect, fn, spyOn }) => {\n  const object = {\n    method() {}\n  };\n\n  const handleClick = fn();\n  spyOn(object, 'method');\n\n  handleClick();\n  object.method();\n  object.method();\n\n  expect(handleClick).toHaveBeenCalledTimes(1);\n  expect(object.method).toHaveBeenCalledTimes(2);\n});\n")),(0,l.kt)("h3",{id:"tohavebeencalledwith"},"toHaveBeenCalledWith"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toHaveBeenCalledWith(...args)")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received")," ",(0,l.kt)("type",null,"Mock")," The mock function"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"args")," ",(0,l.kt)("type",null,"any[]")," Expect arguments")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)("p",null,"Use ",(0,l.kt)("inlineCode",{parentName:"p"},"toHaveBeenCalledWith")," to ensure that a mock function was called with specific arguments. The arguments are checked with the same algorithm that ",(0,l.kt)("inlineCode",{parentName:"p"},"toEqual")," uses."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"import { test } from 'xbell';\n\ntest('toHaveBeenCalledWith', ({ expect, fn, spyOn }) => {\n  const object = {\n    method() {}\n  };\n\n  const handleClick = fn();\n  spyOn(object, 'method');\n\n  handleClick('str');\n  object.method(1, 2);\n\n  expect(handleClick).toHaveBeenCalledWith('str');\n  expect(object.method).toHaveBeenCalledWith(1, 2);\n});\n")),(0,l.kt)("h3",{id:"tohavebeenlastcalledwith"},"toHaveBeenLastCalledWith"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toHaveBeenLastCalledWith(...args)")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received")," ",(0,l.kt)("type",null,"Mock")," The mock function"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"args")," ",(0,l.kt)("type",null,"any[]")," Expect arguments")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)("p",null,"Use ",(0,l.kt)("inlineCode",{parentName:"p"},"toHaveBeenLastCalledWith")," to ensure that the mock function is called the last time with the specified arguments."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"import { test } from 'xbell';\n\ntest('toHaveBeenLastCalledWith', ({ expect, fn, spyOn }) => {\n  const handleClick = fn();\n\n  handleClick('str');\n  handleClick(1, 2);\n\n  expect(handleClick).toHaveBeenCalledWith('str');\n  expect(handleClick).toHaveBeenLastCalledWith(1, 2);\n});\n")),(0,l.kt)("h3",{id:"tohavebeennthcalledwith"},"toHaveBeenNthCalledWith"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toHaveBeenNthCalledWith(nthCall, ...args)")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received")," ",(0,l.kt)("type",null,"Mock")," The mock function"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"nthCall")," ",(0,l.kt)("type",null,"number")," The NTH call"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"args")," ",(0,l.kt)("type",null,"any[]")," Expect arguments")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)("p",null,"Use ",(0,l.kt)("inlineCode",{parentName:"p"},"toHaveBeenNthCalledWith")," to ensure that the mock function was called the nth time with the specified arguments."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"import { test } from 'xbell';\n\ntest('toHaveBeenNthCalledWith', ({ expect, fn, spyOn }) => {\n  const handleClick = fn();\n\n  handleClick('one', 'one');\n  handleClick('two', 'two');\n  handleClick('three', 'three');\n\n  expect(handleClick).toHaveBeenNthCalledWith(1, 'one', 'one');\n  expect(handleClick).toHaveBeenNthCalledWith(3, 'three', 'three');\n});\n")),(0,l.kt)("h3",{id:"tohavereturned"},"toHaveReturned"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toHaveReturned()")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received")," ",(0,l.kt)("type",null,"Mock")," The mock function")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)("p",null,"Use ",(0,l.kt)("inlineCode",{parentName:"p"},"toHaveReturned")," to ensure that a mock function successfully returned (i.e., did not throw an error) at least one time."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"import { test } from 'xbell';\n\ntest('toHaveReturned', ({ expect, fn, spyOn }) => {\n  const add = (a: number, b: number) => a + b;\n  const someOne = {\n    makeSomething() {\n      return 'something';\n    },\n  };\n\n  const mockAdd = fn(add);\n  spyOn(someOne, 'makeSomething');\n\n  add(1, 1);\n  someOne.makeSomething();\n\n  expect(mockAdd).toHaveReturned();\n  expect(someOne.makeSomething).toHaveReturned();\n});\n")),(0,l.kt)("h3",{id:"tohavereturnedtimes"},"toHaveReturnedTimes"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toHaveReturnedTimes(times)")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received")," ",(0,l.kt)("type",null,"Mock")," The mock function"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"times")," ",(0,l.kt)("type",null,"number")," Number of calls")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)("p",null,"Use ",(0,l.kt)("inlineCode",{parentName:"p"},"toHaveReturnedTimes")," to ensure that a mock function returned successfully (i.e., did not throw an error) an exact number of times. Any calls to the mock function that throw an error are not counted toward the number of times the function returned."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"import { test } from 'xbell';\n\ntest('toHaveReturnedTimes', ({ expect, fn, spyOn }) => {\n  const add = (a: number, b: number) => a + b;\n  const someOne = {\n    makeSomething() {\n      return 'something';\n    },\n  };\n\n  const mockAdd = fn(add);\n  spyOn(someOne, 'makeSomething');\n\n  add(1, 1);\n  add(1, 1);\n  someOne.makeSomething();\n  someOne.makeSomething();\n  someOne.makeSomething();\n\n  expect(mockAdd).toHaveReturnedTimes(2);\n  expect(someOne.makeSomething).toHaveReturnedTimes(3);\n});\n")),(0,l.kt)("h3",{id:"tohavereturnedwith"},"toHaveReturnedWith"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toHaveReturnedWith(value)")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received")," ",(0,l.kt)("type",null,"Mock")," The mock function"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"value")," ",(0,l.kt)("type",null,"any")," The return value")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)("p",null,"Use ",(0,l.kt)("inlineCode",{parentName:"p"},"toHaveReturnedWith")," to ensure that a mock function was called with specific return value. The return value are checked with the same algorithm that ",(0,l.kt)("inlineCode",{parentName:"p"},"toEqual")," uses."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"import { test } from 'xbell';\n\ntest('toHaveReturnedWith', ({ expect, fn, spyOn }) => {\n  const add = (a: number, b: number) => a + b;\n  const someOne = {\n    makeSomething() {\n      return 'something';\n    },\n  };\n\n  const mockAdd = fn(add);\n  spyOn(someOne, 'makeSomething');\n\n  add(1, 1);\n  someOne.makeSomething();\n\n  expect(mockAdd).toHaveReturnedWith(2);\n  expect(someOne.makeSomething).toHaveReturnedWith('something');\n});\n")),(0,l.kt)("h3",{id:"tohavelastreturnedwith"},"toHaveLastReturnedWith"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toHaveLastReturnedWith(value)")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received")," ",(0,l.kt)("type",null,"Mock")," The mock function"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"value")," ",(0,l.kt)("type",null,"any")," The return value of the last called")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)("p",null,"Use ",(0,l.kt)("inlineCode",{parentName:"p"},"toHaveLastReturnedWith")," to ensure that a mock function was called the last time with specific return value. The return value are checked with the same algorithm that ",(0,l.kt)("inlineCode",{parentName:"p"},"toEqual")," uses."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"import { test } from 'xbell';\n\ntest('toHaveLastReturnedWith', ({ expect, fn, spyOn }) => {\n  const add = (a: number, b: number) => a + b;\n  const someOne = {\n    makeSomething() {\n      return 'something';\n    },\n  };\n\n  const mockAdd = fn(add);\n  spyOn(someOne, 'makeSomething');\n\n  add(1, 1);\n  add(2, 2);\n  someOne.makeSomething();\n\n  expect(mockAdd).toHaveLastReturnedWith(4);\n  expect(someOne.makeSomething).toHaveLastReturnedWith('something');\n});\n")),(0,l.kt)("h3",{id:"tohaventhreturnedwith"},"toHaveNthReturnedWith"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toHaveNthReturnedWith(nthCall, value)")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received")," ",(0,l.kt)("type",null,"Mock")," The mock function"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"nthCall")," ",(0,l.kt)("type",null,"number")," The NTH call"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"value")," ",(0,l.kt)("type",null,"any")," The return value of the last called")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)("p",null,"Use ",(0,l.kt)("inlineCode",{parentName:"p"},"toHaveNthReturnedWith")," to ensure that a mock function was called the nth time with specific return value. The return value are checked with the same algorithm that ",(0,l.kt)("inlineCode",{parentName:"p"},"toEqual")," uses."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"import { test } from 'xbell';\n\ntest('toHaveNthReturnedWith', ({ expect, fn, spyOn }) => {\n  const add = (a: number, b: number) => a + b;\n  const someOne = {\n    makeSomething() {\n      return 'something';\n    },\n  };\n\n  const mockAdd = fn(add);\n  spyOn(someOne, 'makeSomething');\n\n  add(1, 1);\n  add(20, 20);\n  add(3, 3);\n  someOne.makeSomething();\n\n  expect(mockAdd).toHaveNthReturnedWith(2, 40);\n  expect(someOne.makeSomething).toHaveNthReturnedWith(1, 'something');\n});\n")),(0,l.kt)("h3",{id:"tobevisible-"},"toBeVisible ",(0,l.kt)("tag",{type:"node.js"})),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toBeVisible(options?)")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received")," ",(0,l.kt)("type",null,"Locator | ElementHandle")," Locator or element handle"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"options?")," ",(0,l.kt)("type",null," object "),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"timeout?")," ",(0,l.kt)("type",null,"number")," Time to retry the assertion for.")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)("p",null,"Use ",(0,l.kt)("inlineCode",{parentName:"p"},"toBeVisible")," to ensure that a ",(0,l.kt)("inlineCode",{parentName:"p"},"locator")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"element handle")," points to an attached and visible DOM node."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"import { test } from 'xbell';\n\ntest('toBeVisible', ({ expect, page, spyOn }) => {\n  await page.goto('https://github.com/x-bell/xbell')\n\n  const slogan = page.getByText('Make Web testing easy.')\n\n  await expect(slogan).toBeVisible();\n});\n")),(0,l.kt)("h3",{id:"tobehidden"},"toBeHidden"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Signature: expect(received).toBeHidden(options?)")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"received")," ",(0,l.kt)("type",null,"Locator | ElementHandle")," Locator or element handle"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"options?")," ",(0,l.kt)("type",null," object "),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"timeout?")," ",(0,l.kt)("type",null,"number")," Time to retry the assertion for.")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")," ",(0,l.kt)("type",null,"void")),(0,l.kt)("p",null,"Use ",(0,l.kt)("inlineCode",{parentName:"p"},"toBeHidden")," to ensure that a ",(0,l.kt)("inlineCode",{parentName:"p"},"locator")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"element handle")," either does not resolve to any DOM node, or resolves to a non-visible one."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},"import { test } from 'xbell';\n\ntest('toBeHidden', ({ expect, page, spyOn }) => {\n  await page.goto('https://github.com/x-bell/xbell')\n\n  const slogan = page.getByText('Make Web testing hard.')\n\n  await expect(slogan).toBeHidden();\n});\n")),(0,l.kt)("h3",{id:"tobechecked"},"toBeChecked"),(0,l.kt)("h3",{id:"tobedisabled"},"toBeDisabled"),(0,l.kt)("h3",{id:"tobeempty"},"toBeEmpty"),(0,l.kt)("h3",{id:"tobeenabled"},"toBeEnabled"),(0,l.kt)("h3",{id:"tobefocused"},"toBeFocused"),(0,l.kt)("h3",{id:"tohavetext"},"toHaveText"),(0,l.kt)("h3",{id:"tocontaintext"},"toContainText"),(0,l.kt)("h3",{id:"tohaveattribute"},"toHaveAttribute"),(0,l.kt)("h3",{id:"tohaveclass"},"toHaveClass"),(0,l.kt)("h3",{id:"tohaveid"},"toHaveId"),(0,l.kt)("h3",{id:"tohavecount"},"toHaveCount"),(0,l.kt)("h3",{id:"tomatchimagescreenshot"},"toMatchImageScreenshot"),(0,l.kt)("h3",{id:"tomatchsnapshot"},"toMatchSnapshot"))}c.isMDXComponent=!0}}]);